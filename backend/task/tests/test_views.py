from django.test import TestCase
from django.contrib.auth import get_user_model
from django.urls import reverse
from rest_framework.test import APIClient
from rest_framework import status
from task.models import Task
from core.models import Project, Organization, Team, AdChannel, ProjectMember
from budget_approval.models import BudgetPool, BudgetRequest
from asset.models import Asset
from retrospective.models import RetrospectiveTask

User = get_user_model()


class TaskAPITest(TestCase):
    """Test Task API endpoints"""
    
    def setUp(self):
        """Set up test data"""
        # Clear any existing data
        Task.objects.all().delete()
        
        # Create test users
        self.user = User.objects.create_user(
            email='test@example.com',
            username='testuser',
            password='testpass123'
        )
        self.approver = User.objects.create_user(
            email='approver@example.com',
            username='approver',
            password='testpass123'
        )
        
        # Create test organization and project
        self.organization = Organization.objects.create(
            name="Test Organization"
        )
        self.project = Project.objects.create(
            name="Test Project", 
            organization=self.organization
        )
        ProjectMember.objects.create(
            user=self.user,
            project=self.project,
            role='owner',
            is_active=True
        )
        self.user.active_project = self.project
        self.user.save(update_fields=['active_project'])
        
        # Create test team
        self.team = Team.objects.create(
            organization=self.organization,
            name="Test Team"
        )
        
        # Create test ad channel and budget pool
        self.ad_channel = AdChannel.objects.create(
            name="Test Channel",
            project=self.project
        )
        self.budget_pool = BudgetPool.objects.create(
            project=self.project,
            ad_channel=self.ad_channel,
            total_amount=10000.00,
            currency="AUD"
        )
        
        # Setup API client
        self.client = APIClient()
        self.client.force_authenticate(user=self.user)
    
    def create_task_with_status(self, status, **kwargs):
        """
        Helper method to create a Task with a specific status using FSM transitions.
        This is necessary because FSM fields with protected=True cannot be set directly.
        """
        # Create task without status (defaults to DRAFT)
        task = Task.objects.create(**kwargs)
        
        # Use transitions to reach the desired status
        if status == Task.Status.DRAFT:
            # Already in DRAFT, no transition needed
            pass
        elif status == Task.Status.SUBMITTED:
            task.submit()
            task.save()
        elif status == Task.Status.UNDER_REVIEW:
            task.submit()
            task.start_review()
            task.save()
        elif status == Task.Status.APPROVED:
            task.submit()
            task.start_review()
            task.approve()
            task.save()
        elif status == Task.Status.REJECTED:
            task.submit()
            task.start_review()
            task.reject()
            task.save()
        elif status == Task.Status.CANCELLED:
            task.submit()
            task.cancel()
            task.save()
        elif status == Task.Status.LOCKED:
            task.submit()
            task.start_review()
            task.approve()
            task.lock()
            task.save()
        else:
            raise ValueError(f"Unknown status: {status}")
        
        return task
    
    def test_create_task_success(self):
        """Test successful task creation"""
        url = reverse('task-list')  # URL name generated by DefaultRouter
        data = {
            'summary': 'Test Task',
            'description': 'Test task description',
            'type': 'budget',
            'project_id': self.project.id,
            'due_date': '2024-12-31'
        }
        
        response = self.client.post(url, data, format='json')
        
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        self.assertEqual(Task.objects.count(), 1)
        
        task = Task.objects.first()
        self.assertEqual(task.summary, 'Test Task')
        self.assertEqual(task.type, 'budget')
        self.assertEqual(task.owner, self.user)
        self.assertEqual(task.project, self.project)
        self.assertFalse(task.is_linked)  # Newly created task should not be linked to any object

    def test_create_task_with_project_member_approver_success(self):
        """Task can be created with approver who is a member of the project"""
        # Make approver a member of the same project
        ProjectMember.objects.create(
            user=self.approver,
            project=self.project,
            role='member',
            is_active=True,
        )

        url = reverse('task-list')
        data = {
            'summary': 'Task With Approver',
            'description': 'Has valid approver',
            'type': 'budget',
            'project_id': self.project.id,
            'current_approver_id': self.approver.id,
        }

        response = self.client.post(url, data, format='json')

        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        task = Task.objects.get(summary='Task With Approver')
        self.assertEqual(task.current_approver, self.approver)

    def test_create_task_with_non_member_approver_fails(self):
        """Task creation should fail if approver is not a member of the project"""
        # Note: self.approver is NOT added to ProjectMember for this project
        url = reverse('task-list')
        data = {
            'summary': 'Invalid Approver Task',
            'description': 'Approver not in project',
            'type': 'budget',
            'project_id': self.project.id,
            'current_approver_id': self.approver.id,
        }

        response = self.client.post(url, data, format='json')

        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertIn('current_approver_id', response.data)
        self.assertIn('Approver must be a member of the project.', response.data['current_approver_id'])

    def test_create_task_without_project_id_uses_active_project(self):
        """Task creation should default to user's active project"""
        url = reverse('task-list')
        data = {
            'summary': 'Active Project Task',
            'description': 'Auto project selection',
            'type': 'asset',
        }

        response = self.client.post(url, data, format='json')

        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        task = Task.objects.get(summary='Active Project Task')
        self.assertEqual(task.project_id, self.project.id)

    def test_create_task_with_unowned_project_denied(self):
        """Users cannot create tasks in projects they do not belong to"""
        other_project = Project.objects.create(
            name="Other Project",
            organization=self.organization
        )
        url = reverse('task-list')
        data = {
            'summary': 'Unauthorized Task',
            'type': 'budget',
            'project_id': other_project.id,
        }

        response = self.client.post(url, data, format='json')

        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertIn('project_id', response.data)

    def test_task_response_includes_content_type_and_object_id(self):
        """Test that task response includes content_type and object_id fields"""
        # Create task without linking
        task = Task.objects.create(
            summary='Test Task',
            type='budget',
            owner=self.user,
            project=self.project
        )
        
        # Test GET task detail
        url = reverse('task-detail', kwargs={'pk': task.id})
        response = self.client.get(url)
        
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertIn('content_type', response.data)
        self.assertIn('object_id', response.data)
        self.assertIsNone(response.data['content_type'])  # Should be null for unlinked task
        self.assertIsNone(response.data['object_id'])     # Should be null for unlinked task
        
        # Link task to budget request
        budget_request = BudgetRequest.objects.create(
            requested_by=self.user,
            amount=1000.00,
            currency="AUD",
            budget_pool=self.budget_pool,
            current_approver=self.approver,
            ad_channel=self.ad_channel
        )
        task.link_to_object(budget_request)
        
        # Test GET task detail after linking
        response = self.client.get(url)
        
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertIn('content_type', response.data)
        self.assertIn('object_id', response.data)
        self.assertEqual(response.data['content_type'], 'budgetrequest')
        self.assertEqual(response.data['object_id'], str(budget_request.id))
    
    def test_create_task_missing_required_fields(self):
        """Test task creation with missing required fields"""
        url = reverse('task-list')
        data = {
            'description': 'Test task description',
            'type': 'budget'
            # Missing summary and project_id
        }
        
        response = self.client.post(url, data, format='json')
        
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertEqual(Task.objects.count(), 0)
    
    def test_create_task_invalid_type(self):
        """Test task creation with invalid type"""
        url = reverse('task-list')
        data = {
            'summary': 'Test Task',
            'type': 'invalid_type',
            'project_id': self.project.id
        }
        
        response = self.client.post(url, data, format='json')
        
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertEqual(Task.objects.count(), 0)
    
    def test_link_task_to_budget_request(self):
        """Test linking task to budget request"""
        # Create task
        task = Task.objects.create(
            summary='Test Task',
            type='budget',
            owner=self.user,
            project=self.project
        )
        
        # Create budget request
        budget_request = BudgetRequest.objects.create(
            requested_by=self.user,
            amount=1000.00,
            currency="AUD",
            budget_pool=self.budget_pool,
            current_approver=self.approver,
            ad_channel=self.ad_channel
        )
        
        # Test link
        url = reverse('task-link', kwargs={'pk': task.id})
        data = {
            'content_type': 'budgetrequest',
            'object_id': budget_request.id
        }
        
        response = self.client.post(url, data, format='json')
        
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        
        # Reload task from database to get updated fields (except FSM field)
        task = Task.objects.get(pk=task.pk)
        self.assertTrue(task.is_linked)
        self.assertEqual(task.task_type, 'budgetrequest')
        self.assertEqual(task.linked_object, budget_request)
    
    def test_link_task_to_asset(self):
        """Test linking task to asset"""
        # Create task
        task = Task.objects.create(
            summary='Test Task',
            type='asset',
            owner=self.user,
            project=self.project
        )
        
        # Create asset
        asset = Asset.objects.create(
            owner=self.user,
            team=self.team
        )
        
        # Test link
        url = reverse('task-link', kwargs={'pk': task.id})
        data = {
            'content_type': 'asset',
            'object_id': asset.id
        }
        
        response = self.client.post(url, data, format='json')
        
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        
        # Reload task from database to get updated fields (except FSM field)
        task = Task.objects.get(pk=task.pk)
        self.assertTrue(task.is_linked)
        self.assertEqual(task.task_type, 'asset')
        self.assertEqual(task.linked_object, asset)
    
    def test_link_task_to_retrospective(self):
        """Test linking task to retrospective task"""
        # Create task
        task = Task.objects.create(
            summary='Test Task',
            type='retrospective',
            owner=self.user,
            project=self.project
        )
        
        # Create retrospective task
        retrospective = RetrospectiveTask.objects.create(
            campaign=self.project,
            created_by=self.user
        )
        
        # Test link
        url = reverse('task-link', kwargs={'pk': task.id})
        data = {
            'content_type': 'retrospectivetask',
            'object_id': str(retrospective.id)  # UUID needs to be converted to string
        }
        
        response = self.client.post(url, data, format='json')
        
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        
        # Reload task from database to get updated fields (except FSM field)
        task = Task.objects.get(pk=task.pk)
        self.assertTrue(task.is_linked)
        self.assertEqual(task.task_type, 'retrospectivetask')
        self.assertEqual(task.linked_object, retrospective)
    
    def test_link_task_invalid_content_type(self):
        """Test linking task with invalid content type"""
        task = Task.objects.create(
            summary='Test Task',
            type='budget',
            owner=self.user,
            project=self.project
        )
        
        url = reverse('task-link', kwargs={'pk': task.id})
        data = {
            'content_type': 'invalid_model',
            'object_id': 1
        }
        
        response = self.client.post(url, data, format='json')
        
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
    
    def test_link_task_object_not_found(self):
        """Test linking task to non-existent object"""
        task = Task.objects.create(
            summary='Test Task',
            type='budget',
            owner=self.user,
            project=self.project
        )
        
        url = reverse('task-link', kwargs={'pk': task.id})
        data = {
            'content_type': 'budgetrequest',
            'object_id': 99999  # Non-existent ID
        }
        
        response = self.client.post(url, data, format='json')
        
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
    
    def test_link_task_already_linked(self):
        """Test linking task that is already linked"""
        task = Task.objects.create(
            summary='Test Task',
            type='budget',
            owner=self.user,
            project=self.project
        )
        
        # Create and link first budget request
        budget_request1 = BudgetRequest.objects.create(
            task=task,
            requested_by=self.user,
            amount=1000.00,
            currency="AUD",
            budget_pool=self.budget_pool,
            current_approver=self.approver,
            ad_channel=self.ad_channel
        )
        
        # Link first object
        url = reverse('task-link', kwargs={'pk': task.id})
        data1 = {
            'content_type': 'budgetrequest',
            'object_id': budget_request1.id
        }
        response1 = self.client.post(url, data1, format='json')
        self.assertEqual(response1.status_code, status.HTTP_200_OK)
        
        # Try to link second object
        budget_request2 = BudgetRequest.objects.create(
            requested_by=self.user,
            amount=2000.00,
            currency="AUD",
            budget_pool=self.budget_pool,
            current_approver=self.approver,
            ad_channel=self.ad_channel
        )
        
        data2 = {
            'content_type': 'budgetrequest',
            'object_id': budget_request2.id
        }
        response2 = self.client.post(url, data2, format='json')
        
        # Should return error because task is already linked to an object
        self.assertEqual(response2.status_code, status.HTTP_400_BAD_REQUEST)
    
    def test_get_task_list(self):
        """Test getting list of tasks"""
        # Create multiple tasks
        task1 = Task.objects.create(
            summary='Task 1',
            type='budget',
            owner=self.user,
            project=self.project
        )
        task2 = Task.objects.create(
            summary='Task 2',
            type='asset',
            owner=self.user,
            project=self.project
        )
        
        url = reverse('task-list')
        response = self.client.get(url)
        
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        
        # Check that our created tasks are in the response
        # Handle pagination if present
        tasks = response.data if isinstance(response.data, list) else response.data.get('results', response.data)
        task_summaries = [task['summary'] for task in tasks]
        self.assertIn('Task 1', task_summaries)
        self.assertIn('Task 2', task_summaries)
        
        # Check response structure
        task_data = tasks[0]
        self.assertIn('id', task_data)
        self.assertIn('summary', task_data)
        self.assertIn('type', task_data)
        self.assertIn('status', task_data)
        self.assertIn('owner', task_data)
        self.assertIn('project', task_data)

    def test_get_task_list_excludes_unowned_projects(self):
        """Tasks from projects without membership should not appear"""
        Task.objects.create(
            summary='Owned Task',
            type='budget',
            owner=self.user,
            project=self.project
        )
        other_project = Project.objects.create(
            name="Secret Project",
            organization=self.organization
        )
        Task.objects.create(
            summary='Foreign Task',
            type='asset',
            owner=self.user,
            project=other_project
        )

        url = reverse('task-list')
        response = self.client.get(url)

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        tasks = response.data if isinstance(response.data, list) else response.data.get('results', response.data)
        summaries = [task['summary'] for task in tasks]
        self.assertIn('Owned Task', summaries)
        self.assertNotIn('Foreign Task', summaries)

    def test_get_task_list_with_unauthorized_project_filter(self):
        """Filtering by unauthorized project should raise 403"""
        other_project = Project.objects.create(
            name="Unauthorized Project",
            organization=self.organization
        )
        url = reverse('task-list')
        response = self.client.get(url, {'project_id': other_project.id})

        self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN)
        self.assertIn('detail', response.data)
    
    def test_get_task_list_with_filters(self):
        """Test getting list of tasks with filters"""
        # Create tasks of different types
        budget_task = Task.objects.create(
            summary='Budget Task',
            type='budget',
            owner=self.user,
            project=self.project
        )
        asset_task = Task.objects.create(
            summary='Asset Task',
            type='asset',
            owner=self.user,
            project=self.project
        )
        
        # Test filter by type
        url = reverse('task-list')
        response = self.client.get(url, {'type': 'budget'})
        
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        tasks = response.data if isinstance(response.data, list) else response.data.get('results', response.data)
        self.assertEqual(len(tasks), 1)
        self.assertEqual(tasks[0]['type'], 'budget')
        
        # Test filter by project_id
        response = self.client.get(url, {'project_id': self.project.id})
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        tasks = response.data if isinstance(response.data, list) else response.data.get('results', response.data)
        self.assertEqual(len(tasks), 2)

    def test_get_task_list_with_content_type_filter(self):
        """Test getting list of tasks filtered by content_type"""
        # Create tasks linked to different content types
        budget_task = Task.objects.create(
            summary='Budget Task',
            type='budget',
            owner=self.user,
            project=self.project
        )
        
        asset_task = Task.objects.create(
            summary='Asset Task',
            type='asset',
            owner=self.user,
            project=self.project
        )
        
        # Create budget request and link to budget task
        budget_request = BudgetRequest.objects.create(
            requested_by=self.user,
            amount=1000.00,
            currency="AUD",
            budget_pool=self.budget_pool,
            current_approver=self.approver,
            ad_channel=self.ad_channel
        )
        budget_task.link_to_object(budget_request)
        
        # Create asset and link to asset task
        asset = Asset.objects.create(
            owner=self.user,
            team=self.team
        )
        asset_task.link_to_object(asset)
        
        # Test filter by content_type
        url = reverse('task-list')
        response = self.client.get(url, {'content_type': 'budgetrequest'})
        
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        tasks = response.data if isinstance(response.data, list) else response.data.get('results', response.data)
        self.assertEqual(len(tasks), 1)
        self.assertEqual(tasks[0]['type'], 'budget')
        
        # Test filter by content_type for asset
        response = self.client.get(url, {'content_type': 'asset'})
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        tasks = response.data if isinstance(response.data, list) else response.data.get('results', response.data)
        self.assertEqual(len(tasks), 1)
        self.assertEqual(tasks[0]['type'], 'asset')
        
        # Test invalid content_type
        response = self.client.get(url, {'content_type': 'invalid_model'})
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        tasks = response.data if isinstance(response.data, list) else response.data.get('results', response.data)
        self.assertEqual(len(tasks), 0)  # Should return empty list for invalid content_type

    def test_get_task_list_with_object_id_filter(self):
        """Test getting list of tasks filtered by object_id"""
        # Create tasks
        task1 = Task.objects.create(
            summary='Task 1',
            type='budget',
            owner=self.user,
            project=self.project
        )
        
        task2 = Task.objects.create(
            summary='Task 2',
            type='budget',
            owner=self.user,
            project=self.project
        )
        
        # Create budget requests and link to tasks
        budget_request1 = BudgetRequest.objects.create(
            requested_by=self.user,
            amount=1000.00,
            currency="AUD",
            budget_pool=self.budget_pool,
            current_approver=self.approver,
            ad_channel=self.ad_channel
        )
        task1.link_to_object(budget_request1)
        
        budget_request2 = BudgetRequest.objects.create(
            requested_by=self.user,
            amount=2000.00,
            currency="AUD",
            budget_pool=self.budget_pool,
            current_approver=self.approver,
            ad_channel=self.ad_channel
        )
        task2.link_to_object(budget_request2)
        
        # Test filter by object_id
        url = reverse('task-list')
        response = self.client.get(url, {'object_id': str(budget_request1.id)})
        
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        tasks = response.data if isinstance(response.data, list) else response.data.get('results', response.data)
        self.assertEqual(len(tasks), 1)
        self.assertEqual(tasks[0]['id'], task1.id)
        
        # Test filter by object_id for second task
        response = self.client.get(url, {'object_id': str(budget_request2.id)})
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        tasks = response.data if isinstance(response.data, list) else response.data.get('results', response.data)
        self.assertEqual(len(tasks), 1)
        self.assertEqual(tasks[0]['id'], task2.id)

    def test_get_task_list_with_combined_filters(self):
        """Test getting list of tasks with multiple filters combined"""
        # Create tasks
        budget_task = self.create_task_with_status(
            Task.Status.UNDER_REVIEW,
            summary='Budget Task',
            type='budget',
            owner=self.user,
            project=self.project
        )
        
        asset_task = self.create_task_with_status(
            Task.Status.DRAFT,
            summary='Asset Task',
            type='asset',
            owner=self.user,
            project=self.project
        )
        
        # Create and link objects
        budget_request = BudgetRequest.objects.create(
            requested_by=self.user,
            amount=1000.00,
            currency="AUD",
            budget_pool=self.budget_pool,
            current_approver=self.approver,
            ad_channel=self.ad_channel
        )
        budget_task.link_to_object(budget_request)
        
        asset = Asset.objects.create(
            owner=self.user,
            team=self.team
        )
        asset_task.link_to_object(asset)
        
        # Test combined filters: type + content_type + object_id
        url = reverse('task-list')
        response = self.client.get(url, {
            'type': 'budget',
            'content_type': 'budgetrequest',
            'object_id': str(budget_request.id)
        })
        
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        tasks = response.data if isinstance(response.data, list) else response.data.get('results', response.data)
        self.assertEqual(len(tasks), 1)
        self.assertEqual(tasks[0]['id'], budget_task.id)
        self.assertEqual(tasks[0]['type'], 'budget')

    def test_get_task_detail(self):
        """Test getting a specific task"""
        task = Task.objects.create(
            summary='Test Task',
            type='budget',
            owner=self.user,
            project=self.project
        )
        
        url = reverse('task-detail', kwargs={'pk': task.id})
        response = self.client.get(url)
        
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data['id'], task.id)
        self.assertEqual(response.data['summary'], 'Test Task')
        self.assertEqual(response.data['type'], 'budget')
        self.assertEqual(response.data['status'], 'DRAFT')
    
    def test_get_task_detail_not_found(self):
        """Test getting a non-existent task"""
        url = reverse('task-detail', kwargs={'pk': 99999})
        response = self.client.get(url)
        
        self.assertEqual(response.status_code, status.HTTP_404_NOT_FOUND)
    
    def test_update_task_success(self):
        """Test updating a task"""
        task = Task.objects.create(
            summary='Original Summary',
            type='budget',
            owner=self.user,
            project=self.project
        )
        
        url = reverse('task-detail', kwargs={'pk': task.id})
        data = {
            'summary': 'Updated Summary',
            'description': 'Updated description',
            'due_date': '2024-12-31'
        }
        
        response = self.client.patch(url, data, format='json')
        
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data['summary'], 'Updated Summary')
        self.assertEqual(response.data['description'], 'Updated description')
        
        # Verify database was updated (avoid FSM field refresh)
        task = Task.objects.get(pk=task.id)
        self.assertEqual(task.summary, 'Updated Summary')
    
    def test_update_task_project_id_null_keeps_existing(self):
        """Explicit null project_id should leave project unchanged"""
        task = Task.objects.create(
            summary='Keep Project',
            type='budget',
            owner=self.user,
            project=self.project
        )

        url = reverse('task-detail', kwargs={'pk': task.id})
        response = self.client.patch(url, {'project_id': None}, format='json')

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        # Refresh only specific fields to avoid FSM field refresh issues
        task.refresh_from_db(fields=['project_id'])
        self.assertEqual(task.project_id, self.project.id)

    def test_update_task_not_found(self):
        """Test updating a non-existent task"""
        url = reverse('task-detail', kwargs={'pk': 99999})
        data = {'summary': 'Updated Summary'}
        
        response = self.client.patch(url, data, format='json')
        
        self.assertEqual(response.status_code, status.HTTP_404_NOT_FOUND)
    
    def test_update_task_invalid_project_id(self):
        """Test updating task with invalid project_id"""
        task = Task.objects.create(
            summary='Test Task',
            type='budget',
            owner=self.user,
            project=self.project
        )
        
        url = reverse('task-detail', kwargs={'pk': task.id})
        data = {'project_id': 99999}  # Non-existent project
        
        response = self.client.patch(url, data, format='json')
        
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertIn('project_id', response.data)

    def test_update_task_type_field_rejected(self):
        """Test that type field is rejected during task update"""
        task = Task.objects.create(
            summary='Test Task',
            type='budget',
            owner=self.user,
            project=self.project
        )
        
        url = reverse('task-detail', kwargs={'pk': task.id})
        data = {
            'summary': 'Updated Summary',
            'type': 'asset'  # Try to change type
        }
        
        response = self.client.patch(url, data, format='json')
        
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertIn('type', response.data)
        self.assertEqual(response.data['type'][0], 'Task type cannot be modified after creation.')
        
        # Verify that task was NOT updated at all
        task = Task.objects.get(pk=task.id)
        self.assertEqual(task.summary, 'Test Task')  # Should remain unchanged
        self.assertEqual(task.type, 'budget')  # Should remain 'budget'
    
    def test_approve_task_success(self):
        """Test approving a task"""
        # Create task in UNDER_REVIEW status
        task = self.create_task_with_status(
            Task.Status.UNDER_REVIEW,
            summary='Test Task',
            type='budget',
            owner=self.user,
            project=self.project,
            current_approver=self.approver
        )
        
        url = reverse('task-make-approval', kwargs={'pk': task.id})
        data = {
            'action': 'approve',
            'comment': 'Approved for budget allocation'
        }
        
        response = self.client.post(url, data, format='json')
        
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        
        # Check response contains approval_record and task
        self.assertIn('approval_record', response.data)
        self.assertIn('task', response.data)
        
        # Check approval record data
        approval_record = response.data['approval_record']
        self.assertIn('id', approval_record)
        self.assertIn('approved_by', approval_record)
        self.assertIn('is_approved', approval_record)
        self.assertIn('comment', approval_record)
        self.assertIn('step_number', approval_record)
        
        self.assertEqual(approval_record['approved_by']['id'], self.approver.id)
        self.assertTrue(approval_record['is_approved'])
        self.assertEqual(approval_record['comment'], 'Approved for budget allocation')
        self.assertEqual(approval_record['step_number'], 1)
        
        # Check approval record was created in database
        self.assertEqual(task.approval_records.count(), 1)
        approval_record = task.approval_records.first()
        self.assertEqual(approval_record.approved_by, self.approver)
        self.assertTrue(approval_record.is_approved)
        self.assertEqual(approval_record.comment, 'Approved for budget allocation')
        self.assertEqual(approval_record.step_number, 1)
    
    
    def test_approve_task_invalid_status(self):
        """Test approving a task that is not in UNDER_REVIEW status"""
        task = self.create_task_with_status(
            Task.Status.DRAFT,
            summary='Test Task',
            type='budget',
            owner=self.user,
            project=self.project,
            current_approver=self.approver
        )
        
        url = reverse('task-make-approval', kwargs={'pk': task.id})
        data = {'action': 'approve', 'comment': 'Should not work'}
        
        response = self.client.post(url, data, format='json')
        
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertEqual(task.approval_records.count(), 0)
    
    def test_reject_task_success(self):
        """Test rejecting a task"""
        task = self.create_task_with_status(
            Task.Status.UNDER_REVIEW,
            summary='Test Task',
            type='budget',
            owner=self.user,
            project=self.project,
            current_approver=self.approver
        )
        
        url = reverse('task-make-approval', kwargs={'pk': task.id})
        data = {
            'action': 'reject',
            'comment': 'Insufficient budget documentation'
        }
        
        response = self.client.post(url, data, format='json')
        
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        
        # Check response contains approval_record and task
        self.assertIn('approval_record', response.data)
        self.assertIn('task', response.data)
        
        # Check approval record data
        approval_record = response.data['approval_record']
        self.assertIn('id', approval_record)
        self.assertIn('approved_by', approval_record)
        self.assertIn('is_approved', approval_record)
        self.assertIn('comment', approval_record)
        self.assertIn('step_number', approval_record)
        
        self.assertEqual(approval_record['approved_by']['id'], self.approver.id)
        self.assertFalse(approval_record['is_approved'])
        self.assertEqual(approval_record['comment'], 'Insufficient budget documentation')
        self.assertEqual(approval_record['step_number'], 1)
        
        # Check approval record was created in database
        self.assertEqual(task.approval_records.count(), 1)
        approval_record = task.approval_records.first()
        self.assertEqual(approval_record.approved_by, self.approver)
        self.assertFalse(approval_record.is_approved)
        self.assertEqual(approval_record.comment, 'Insufficient budget documentation')
        self.assertEqual(approval_record.step_number, 1)
    
    def test_reject_task_invalid_status(self):
        """Test rejecting a task that is not in UNDER_REVIEW status"""
        task = self.create_task_with_status(
            Task.Status.DRAFT,
            summary='Test Task',
            type='budget',
            owner=self.user,
            project=self.project,
            current_approver=self.approver
        )
        
        url = reverse('task-make-approval', kwargs={'pk': task.id})
        data = {'action': 'reject', 'comment': 'Should not work'}
        
        response = self.client.post(url, data, format='json')
        
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertEqual(task.approval_records.count(), 0)
    
    def test_cancel_task_success(self):
        """Test cancelling a task"""
        task = self.create_task_with_status(
            Task.Status.SUBMITTED,
            summary='Test Task',
            type='budget',
            owner=self.user,
            project=self.project,
            current_approver=self.approver
        )
        
        # Create some approval records first
        from task.models import ApprovalRecord
        ApprovalRecord.objects.create(
            task=task,
            approved_by=self.approver,
            is_approved=True,
            comment='Previous approval',
            step_number=1
        )
        
        url = reverse('task-cancel', kwargs={'pk': task.id})
        response = self.client.post(url, {}, format='json')
        
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data['task']['status'], 'CANCELLED')
        
        # Check all approval records were deleted
        self.assertEqual(task.approval_records.count(), 0)
    
    def test_cancel_task_invalid_status(self):
        """Test cancelling a task that is not in cancellable status"""
        task = self.create_task_with_status(
            Task.Status.DRAFT,
            summary='Test Task',
            type='budget',
            owner=self.user,
            project=self.project,
            current_approver=self.approver
        )
        
        url = reverse('task-cancel', kwargs={'pk': task.id})
        data = {'comment': 'Should not work'}
        
        response = self.client.post(url, data, format='json')
        
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
    
    def test_approve_task_multiple_steps(self):
        """Test approving a task with multiple approval steps"""
        task = self.create_task_with_status(
            Task.Status.UNDER_REVIEW,
            summary='Test Task',
            type='budget',
            owner=self.user,
            project=self.project,
            current_approver=self.approver
        )
        
        # Create first approval record
        from task.models import ApprovalRecord
        ApprovalRecord.objects.create(
            task=task,
            approved_by=self.user,
            is_approved=True,
            comment='First approval',
            step_number=1
        )
        
        # Approve again (second step)
        url = reverse('task-make-approval', kwargs={'pk': task.id})
        data = {'action': 'approve', 'comment': 'Second approval'}
        
        response = self.client.post(url, data, format='json')
        
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        
        # Check response contains approval_record and task
        self.assertIn('approval_record', response.data)
        self.assertIn('task', response.data)
        
        # Check approval record data
        approval_record = response.data['approval_record']
        self.assertIn('id', approval_record)
        self.assertIn('approved_by', approval_record)
        self.assertIn('is_approved', approval_record)
        self.assertIn('comment', approval_record)
        self.assertIn('step_number', approval_record)
        
        self.assertEqual(approval_record['approved_by']['id'], self.approver.id)
        self.assertTrue(approval_record['is_approved'])
        self.assertEqual(approval_record['comment'], 'Second approval')
        self.assertEqual(approval_record['step_number'], 2)
        
        # Check second approval record was created in database
        self.assertEqual(task.approval_records.count(), 2)
        second_approval = task.approval_records.filter(step_number=2).first()
        self.assertIsNotNone(second_approval)
        self.assertEqual(second_approval.approved_by, self.approver)
        self.assertTrue(second_approval.is_approved)
        self.assertEqual(second_approval.comment, 'Second approval')
    
    def test_make_approval_invalid_action(self):
        """Test make-approval with invalid action"""
        task = self.create_task_with_status(
            Task.Status.UNDER_REVIEW,
            summary='Test Task',
            type='budget',
            owner=self.user,
            project=self.project,
            current_approver=self.approver
        )
        
        url = reverse('task-make-approval', kwargs={'pk': task.id})
        data = {'action': 'invalid_action', 'comment': 'Should not work'}
        
        response = self.client.post(url, data, format='json')
        
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertEqual(task.approval_records.count(), 0)
    
    def test_make_approval_missing_action(self):
        """Test make-approval with missing action"""
        task = self.create_task_with_status(
            Task.Status.UNDER_REVIEW,
            summary='Test Task',
            type='budget',
            owner=self.user,
            project=self.project,
            current_approver=self.approver
        )
        
        url = reverse('task-make-approval', kwargs={'pk': task.id})
        data = {'comment': 'Should not work'}
        
        response = self.client.post(url, data, format='json')
        
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertEqual(task.approval_records.count(), 0)
    
    def test_get_approval_history_success(self):
        """Test getting approval history for a task"""
        task = self.create_task_with_status(
            Task.Status.UNDER_REVIEW,
            summary='Test Task',
            type='budget',
            owner=self.user,
            project=self.project,
            current_approver=self.approver
        )
        
        # Create some approval records
        from task.models import ApprovalRecord
        ApprovalRecord.objects.create(
            task=task,
            approved_by=self.user,
            is_approved=True,
            comment='First approval',
            step_number=1
        )
        ApprovalRecord.objects.create(
            task=task,
            approved_by=self.approver,
            is_approved=False,
            comment='Rejected due to issues',
            step_number=2
        )
        
        url = reverse('task-approval-history', kwargs={'pk': task.id})
        response = self.client.get(url)
        
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertIn('history', response.data)
        history = response.data['history']
        self.assertEqual(len(history), 2)
        
        # Check first approval record
        first_record = history[0]
        self.assertEqual(first_record['step_number'], 1)
        self.assertTrue(first_record['is_approved'])
        self.assertEqual(first_record['comment'], 'First approval')
        self.assertEqual(first_record['approved_by']['id'], self.user.id)
        
        # Check second approval record
        second_record = history[1]
        self.assertEqual(second_record['step_number'], 2)
        self.assertFalse(second_record['is_approved'])
        self.assertEqual(second_record['comment'], 'Rejected due to issues')
        self.assertEqual(second_record['approved_by']['id'], self.approver.id)
    
    def test_get_approval_history_empty(self):
        """Test getting approval history for a task with no approval records"""
        task = self.create_task_with_status(
            Task.Status.DRAFT,
            summary='Test Task',
            type='budget',
            owner=self.user,
            project=self.project
        )
        
        url = reverse('task-approval-history', kwargs={'pk': task.id})
        response = self.client.get(url)
        
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertIn('history', response.data)
        self.assertEqual(len(response.data['history']), 0)
    
    def test_get_approval_history_task_not_found(self):
        """Test getting approval history for non-existent task"""
        url = reverse('task-approval-history', kwargs={'pk': 99999})
        response = self.client.get(url)
        
        self.assertEqual(response.status_code, status.HTTP_404_NOT_FOUND)
    
    def test_revise_task_success(self):
        """Test revising a task"""
        task = self.create_task_with_status(
            Task.Status.REJECTED,
            summary='Test Task',
            type='budget',
            owner=self.user,
            project=self.project,
            current_approver=self.approver
        )
        
        url = reverse('task-revise', kwargs={'pk': task.id})
        response = self.client.post(url, {}, format='json')
        
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data['task']['status'], 'DRAFT')
        
        # Check that current_approver was NOT changed
        task = Task.objects.get(pk=task.pk)
        self.assertEqual(task.current_approver, self.approver)
    
    def test_revise_task_without_comment(self):
        """Test revising a task without comment"""
        task = self.create_task_with_status(
            Task.Status.REJECTED,
            summary='Test Task',
            type='budget',
            owner=self.user,
            project=self.project,
            current_approver=self.approver
        )
        
        url = reverse('task-revise', kwargs={'pk': task.id})
        response = self.client.post(url, {}, format='json')
        
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data['task']['status'], 'DRAFT')
        
        # Check that current_approver was NOT changed
        task = Task.objects.get(pk=task.pk)
        self.assertEqual(task.current_approver, self.approver)
    
    def test_revise_task_invalid_status(self):
        """Test revising a task that is not in REJECTED or CANCELLED status"""
        task = self.create_task_with_status(
            Task.Status.DRAFT,
            summary='Test Task',
            type='budget',
            owner=self.user,
            project=self.project,
            current_approver=self.approver
        )
        
        url = reverse('task-revise', kwargs={'pk': task.id})
        response = self.client.post(url, {}, format='json')
        
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertEqual(task.status, Task.Status.DRAFT)  # Status should not change
    
    def test_revise_task_from_cancelled_status(self):
        """Test revising a task from CANCELLED status"""
        task = self.create_task_with_status(
            Task.Status.CANCELLED,
            summary='Test Task',
            type='budget',
            owner=self.user,
            project=self.project,
            current_approver=self.approver
        )
        
        url = reverse('task-revise', kwargs={'pk': task.id})
        response = self.client.post(url, {}, format='json')
        
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data['task']['status'], 'DRAFT')
        
        # Check that current_approver was NOT changed
        task = Task.objects.get(pk=task.pk)
        self.assertEqual(task.current_approver, self.approver)
    
    def test_forward_task_success(self):
        """Test forwarding a task to next approver"""
        # Create a third user as the new approver
        new_approver = User.objects.create_user(
            email='newapprover@example.com',
            username='newapprover',
            password='testpass123'
        )
        
        task = self.create_task_with_status(
            Task.Status.APPROVED,
            summary='Test Task',
            type='budget',
            owner=self.user,
            project=self.project,
            current_approver=self.approver
        )
        
        url = reverse('task-forward', kwargs={'pk': task.id})
        data = {
            'next_approver_id': new_approver.id,
            'comment': 'Forwarded for next approval'
        }
        
        response = self.client.post(url, data, format='json')
        
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data['task']['status'], 'UNDER_REVIEW')
        
        # Check that current_approver was updated
        task = Task.objects.get(pk=task.pk)
        self.assertEqual(task.current_approver, new_approver)
    
    def test_forward_task_invalid_status(self):
        """Test forwarding a task that is not in APPROVED status"""
        new_approver = User.objects.create_user(
            email='newapprover@example.com',
            username='newapprover',
            password='testpass123'
        )
        
        task = self.create_task_with_status(
            Task.Status.DRAFT,
            summary='Test Task',
            type='budget',
            owner=self.user,
            project=self.project,
            current_approver=self.approver
        )
        
        url = reverse('task-forward', kwargs={'pk': task.id})
        data = {
            'next_approver_id': new_approver.id,
            'comment': 'Should not work'
        }
        
        response = self.client.post(url, data, format='json')
        
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertEqual(task.status, Task.Status.DRAFT)  # Status should not change
    
    def test_forward_task_missing_next_approver(self):
        """Test forwarding a task without providing next_approver_id"""
        task = self.create_task_with_status(
            Task.Status.APPROVED,
            summary='Test Task',
            type='budget',
            owner=self.user,
            project=self.project,
            current_approver=self.approver
        )
        
        url = reverse('task-forward', kwargs={'pk': task.id})
        data = {
            'comment': 'Should not work without next_approver_id'
        }
        
        response = self.client.post(url, data, format='json')
        
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertEqual(task.status, Task.Status.APPROVED)  # Status should not change
    
    def test_forward_task_invalid_next_approver(self):
        """Test forwarding a task with non-existent next_approver_id"""
        task = self.create_task_with_status(
            Task.Status.APPROVED,
            summary='Test Task',
            type='budget',
            owner=self.user,
            project=self.project,
            current_approver=self.approver
        )
        
        url = reverse('task-forward', kwargs={'pk': task.id})
        data = {
            'next_approver_id': 99999,  # Non-existent user
            'comment': 'Should not work'
        }
        
        response = self.client.post(url, data, format='json')
        
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertEqual(task.status, Task.Status.APPROVED)  # Status should not change

    def test_start_review_task_success(self):
        """Test starting review for a task"""
        task = self.create_task_with_status(
            Task.Status.SUBMITTED,
            summary='Test Task',
            type='budget',
            owner=self.user,
            project=self.project,
            current_approver=self.approver
        )
        
        url = reverse('task-start-review', kwargs={'pk': task.id})
        response = self.client.post(url, {}, format='json')
        
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data['task']['status'], 'UNDER_REVIEW')
        
        # Verify database was updated
        task = Task.objects.get(pk=task.pk)
        self.assertEqual(task.status, Task.Status.UNDER_REVIEW)

    def test_start_review_task_invalid_status(self):
        """Test starting review for a task that is not in SUBMITTED status"""
        task = self.create_task_with_status(
            Task.Status.DRAFT,
            summary='Test Task',
            type='budget',
            owner=self.user,
            project=self.project,
            current_approver=self.approver
        )
        
        url = reverse('task-start-review', kwargs={'pk': task.id})
        response = self.client.post(url, {}, format='json')
        
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertEqual(task.status, Task.Status.DRAFT)  # Status should not change

    def test_lock_task_success(self):
        """Test locking a task"""
        task = self.create_task_with_status(
            Task.Status.APPROVED,
            summary='Test Task',
            type='budget',
            owner=self.user,
            project=self.project,
            current_approver=self.approver
        )
        
        url = reverse('task-lock', kwargs={'pk': task.id})
        response = self.client.post(url, {}, format='json')
        
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data['task']['status'], 'LOCKED')
        
        # Verify database was updated
        task = Task.objects.get(pk=task.pk)
        self.assertEqual(task.status, Task.Status.LOCKED)

    def test_lock_task_invalid_status(self):
        """Test locking a task that is not in lockable status"""
        task = self.create_task_with_status(
            Task.Status.DRAFT,
            summary='Test Task',
            type='budget',
            owner=self.user,
            project=self.project,
            current_approver=self.approver
        )
        
        url = reverse('task-lock', kwargs={'pk': task.id})
        response = self.client.post(url, {}, format='json')
        
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertEqual(task.status, Task.Status.DRAFT)  # Status should not change
